Граф — это нелинейная структура данных, состоящая из узлов и ребер. Узлы иногда также называют вершинами, а ребра — линиями или дугами, соединяющими любые два узла в графе.

Типы графов
1) Графы бывают ориентированные (направленные) и неориентированные (ненаправленные).

Ориентированный граф характеризует связь вершин только в одном направлении. Обратный граф может быть, но он должен явно указан.
В неориентированном графе по любому ребру можно пройти в обе стороны.

2) Рёбра графов могут иметь веса, тогда граф называется взвешенным.

3) Циклический граф если можно стартовать в некоторой вершине и вернуться в неё после перемещения по рёбрам, не проходя дважды по одному ребру. Ациклический граф, если в нём нет циклов (если граф при этом неориентированный и связный, он называется «дерево». Они разбираются отдельно в статье ниже).
Двумя наиболее часто используемыми представлениями графа являются:

Представления графов
1. Матрица смежности - представляет собой двумерный массив размером V x V, где V — количество вершин в графе. В пересечении матрицы записывается 1, если существует ребро между вершинами, и записывается 0, если его нет. Матрица смежности для неориентированного графа всегда симметрична. Матрица смежности также используется для представления взвешенных графов, где на пересечении вместо 1 указывается вес ребра.

2. Список смежности - используется массив списков. Размер массива равен количеству вершин. Элемент array[i] представляет собой список вершин, смежных с i -й вершиной. Это представление также можно использовать для представления взвешенного графа. Веса ребер могут быть представлены в виде списков пар.

В Матрице смежности легко обрабатывать информацию о ребрах, но при добавлении вершины занимает больше времени O(n^2). Удаление ребра занимает O(1) времени. Вычисление соседних вершин занимает O(n).

В Списке смежности добавление вершины производится быстрее. Вычисление всех соседей вершины занимает оптимальное время. Поиск ребра между вершинами занимает большее время O(n)

1. Поиск в глубину
“Поиск в глубину” или “обход в глубину” — это алгоритм по поиску всех вершин графа или дерева. Обход подразумевает под собой посещение всех вершин графа. 
Стандартная реализация поиска в глубину помещает каждую вершину графа в одну из двух категорий: пройденные или не пройденные. Цель алгоритма состоит в том, чтобы пометить каждую вершину как “Пройденная”, избегая при этом циклов.
Алгоритм поиска в глубину работает следующим образом:
1.	Начните с того, что поместите любую вершину графа на вершину стека.
2.	Возьмите верхний элемент стека и добавьте его в список “Пройденных”.
3.	Создайте список смежных вершин для этой вершины. Добавьте те вершины, которых нет в списке “Пройденных”, в верх стека.
4.	Необходимо повторять шаги 2 и 3, пока стек не станет пустым.
Применения алгоритма:
•	Для поиска пути.
•	Для проверки двудольности графа.
•	Для поиска сильно связанных компонентов графа.
•	Для обнаружения циклов в графе.
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.

2. Поиск в ширину
Поиск в ширину — один из методов обхода графа. 
Шаги работы алгоритма:
•	Поместить узел, с которого начинается поиск, в изначально пустую очередь.
•	Извлечь из начала очереди узел u и пометить его как развёрнутый.
•	Если узел u является целевым узлом, то завершить поиск с результатом «успех».
•	В противном случае, в конец очереди добавляются все преемники узла u, которые ещё не развёрнуты и не находятся в очереди.
•	Если очередь пуста, то все узлы связного графа были просмотрены, следовательно, целевой узел недостижим из начального; завершить поиск с результатом «неудача».
•	Вернуться к п. 2.
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.
Поиск в ширину может применяться для решения задач, связанных с теорией графов:
•	Волновой алгоритм поиска пути в лабиринте
•	Поиск компонент связности в графе
•	Поиск кратчайшего пути между двумя узлами невзвешенного графа
•	Нахождение кратчайшего цикла в ориентированном невзвешенном графе

3. Алгоритм Прима — алгоритм построения минимального остовного дерева взвешенного связного неориентированного графа. 
На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

Результатом работы алгоритма является остовное дерево минимальной стоимости.

4. Алгоритм Дейкстры
Алгоритм Дейкстры — алгоритм на графах, применяющийся для нахождения кратчайших путей от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.
Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.
Инициализация.
Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.
Шаг алгоритма.
•	Если все вершины посещены, алгоритм завершается.
•	В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.
•	Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.
•	Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

5. Алгоритм Флойда-Уоршелла
Алгоритм Флойда Уоршелла представляет собой алгоритм поиска кратчайшего пути для всех пар, в отличие от Дейкстры и Беллмана-Форда, которые представляют собой алгоритмы поиска кратчайшего пути для одной вершины. Этот алгоритм работает как для ориентированных, так и для неориентированных взвешенных графов, а также для графов как с положительными, так и с отрицательными весами ребер, но не работает для графов с отрицательными циклами (где сумма ребер в цикле отрицательна). Он следует подходу динамического программирования, который проверяет каждый возможный путь, проходящий через каждый возможный узел, чтобы вычислить кратчайшее расстояние между каждой парой узлов.
•	В качестве первого шага инициализируйте матрицу решения так же, как матрицу входного графа. 
•	Затем обновите матрицу решения, рассматривая все вершины как промежуточные. 
•	Идея состоит в том, чтобы выбрать все вершины одну за другой и обновить все кратчайшие пути, которые включают выбранную вершину в качестве промежуточной вершины в кратчайшем пути. 
•	Когда мы выбираем вершину номер k в качестве промежуточной вершины, мы уже рассматриваем вершины {0, 1, 2, .. k-1} как промежуточные вершины. 
•	Для каждой пары (i, j) вершин источника и назначения соответственно есть два возможных случая. 
•	k не является промежуточной вершиной на кратчайшем пути от i до j . Мы сохраняем значение dist[i][j] как есть. 
•	k — промежуточная вершина на кратчайшем пути от i до j . Мы обновляем значение dist[i][j] как dist[i][k] + dist[k][j], если dist[i][j] > dist[i][k] + dist[k] [j]

6.	Алгоритм Беллмана-Форда 
Алгоритм Беллмана-Форда — алгоритм поиска кратчайшего пути во взвешенном графе. В отличие от алгоритма Дейкстры, алгоритм Беллмана-Форда допускает рёбра с отрицательным весом.
Алгоритм работает следующим образом:
Заведём массив расстояний d[0..n-1], который после отработки алгоритма будет содержать ответ на задачу. В начале работы мы заполняем его следующим образом: d[v]=0, а все остальные элементы d[] равны бесконечности.
Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию (relax, ослабление) вдоль каждого ребра (a,b) стоимости c. Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a]+c. Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a.
Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют). Для недостижимых вершин расстояние d[] останется равным бесконечности.
