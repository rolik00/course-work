<!DOCTYPE html>
<html>
<head>
    <title>Заголовки и абзацы</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>Графы</h1>
    <hr>
    <p> Граф — это нелинейная структура данных, состоящая из узлов и ребер. Узлы иногда также называют вершинами, а ребра — линиями или дугами, соединяющими любые два узла в графе.<br>

<h3>Типы графов</h3>
1) Графы бывают ориентированные (направленные) и неориентированные (ненаправленные).<br>

Ориентированный граф характеризует связь вершин только в одном направлении. Обратный граф может быть, но он должен явно указан.
В неориентированном графе по любому ребру можно пройти в обе стороны.<br>

2) Рёбра графов могут иметь веса, тогда граф называется взвешенным.<br>

3) Циклический граф если можно стартовать в некоторой вершине и вернуться в неё после перемещения по рёбрам, не проходя дважды по одному ребру. Ациклический граф, если в нём нет циклов (если граф при этом неориентированный и связный, он называется «дерево». Они разбираются отдельно в статье ниже).
Двумя наиболее часто используемыми представлениями графа являются:<br>

<h3>Представления графов</h3>
1. Матрица смежности - представляет собой двумерный массив размером V x V, где V — количество вершин в графе. В пересечении матрицы записывается 1, если существует ребро между вершинами, и записывается 0, если его нет. Матрица смежности для неориентированного графа всегда симметрична. Матрица смежности также используется для представления взвешенных графов, где на пересечении вместо 1 указывается вес ребра.<br>

2. Список смежности - используется массив списков. Размер массива равен количеству вершин. Элемент array[i] представляет собой список вершин, смежных с i -й вершиной. Это представление также можно использовать для представления взвешенного графа. Веса ребер могут быть представлены в виде списков пар.<br>

В Матрице смежности легко обрабатывать информацию о ребрах, но при добавлении вершины занимает больше времени O(n^2). Удаление ребра занимает O(1) времени. Вычисление соседних вершин занимает O(n).<br>

В Списке смежности добавление вершины производится быстрее. Вычисление всех соседей вершины занимает оптимальное время. Поиск ребра между вершинами занимает большее время O(n)<br>

<h2>1. Поиск в глубину</h2>
“Поиск в глубину” или “обход в глубину” — это алгоритм по поиску всех вершин графа или дерева. Обход подразумевает под собой посещение всех вершин графа. 
Стандартная реализация поиска в глубину помещает каждую вершину графа в одну из двух категорий: пройденные или не пройденные. Цель алгоритма состоит в том, чтобы пометить каждую вершину как “Пройденная”, избегая при этом циклов.<br>
Алгоритм поиска в глубину работает следующим образом:<br>
1.	Начните с того, что поместите любую вершину графа на вершину стека.<br>
2.	Возьмите верхний элемент стека и добавьте его в список “Пройденных”.<br>
3.	Создайте список смежных вершин для этой вершины. Добавьте те вершины, которых нет в списке “Пройденных”, в верх стека.<br>
4.	Необходимо повторять шаги 2 и 3, пока стек не станет пустым.<br>
Применения алгоритма:<br>
•	Для поиска пути.<br>
•	Для проверки двудольности графа.<br>
•	Для поиска сильно связанных компонентов графа.<br>
•	Для обнаружения циклов в графе.<br>
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.<br>

<h2>2. Поиск в ширину</h2>
Поиск в ширину — один из методов обхода графа. <br>
Шаги работы алгоритма:<br>
•	Поместить узел, с которого начинается поиск, в изначально пустую очередь.<br>
•	Извлечь из начала очереди узел u и пометить его как развёрнутый.<br>
•	Если узел u является целевым узлом, то завершить поиск с результатом «успех».<br>
•	В противном случае, в конец очереди добавляются все преемники узла u, которые ещё не развёрнуты и не находятся в очереди.<br>
•	Если очередь пуста, то все узлы связного графа были просмотрены, следовательно, целевой узел недостижим из начального; завершить поиск с результатом «неудача».<br>
•	Вернуться к п. 2.<br>
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.<br>
Поиск в ширину может применяться для решения задач, связанных с теорией графов:<br>
•	Волновой алгоритм поиска пути в лабиринте<br>
•	Поиск компонент связности в графе<br>
•	Поиск кратчайшего пути между двумя узлами невзвешенного графа<br>
•	Нахождение кратчайшего цикла в ориентированном невзвешенном графе<br>

<h2>3. Алгоритм Прима</h2>
Алгоритм Прима— алгоритм построения минимального остовного дерева взвешенного связного неориентированного графа. <br>
На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.<br>

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.<br>

Результатом работы алгоритма является остовное дерево минимальной стоимости.<br>

<h2>4. Алгоритм Дейкстры</h2>
Алгоритм Дейкстры — алгоритм на графах, применяющийся для нахождения кратчайших путей от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.<br>
Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.<br>
Инициализация.<br>
Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.<br>
Шаг алгоритма.<br>
•	Если все вершины посещены, алгоритм завершается.<br>
•	В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.<br>
•	Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.<br>
•	Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.<br>

<h2>5. Алгоритм Флойда-Уоршелла</h2>
Алгоритм Флойда Уоршелла представляет собой алгоритм поиска кратчайшего пути для всех пар, в отличие от Дейкстры и Беллмана-Форда, которые представляют собой алгоритмы поиска кратчайшего пути для одной вершины. Этот алгоритм работает как для ориентированных, так и для неориентированных взвешенных графов, а также для графов как с положительными, так и с отрицательными весами ребер, но не работает для графов с отрицательными циклами (где сумма ребер в цикле отрицательна). Он следует подходу динамического программирования, который проверяет каждый возможный путь, проходящий через каждый возможный узел, чтобы вычислить кратчайшее расстояние между каждой парой узлов.<br>
•	В качестве первого шага инициализируйте матрицу решения так же, как матрицу входного графа.<br> 
•	Затем обновите матрицу решения, рассматривая все вершины как промежуточные. <br>
•	Идея состоит в том, чтобы выбрать все вершины одну за другой и обновить все кратчайшие пути, которые включают выбранную вершину в качестве промежуточной вершины в кратчайшем пути. <br>
•	Когда мы выбираем вершину номер k в качестве промежуточной вершины, мы уже рассматриваем вершины {0, 1, 2, .. k-1} как промежуточные вершины. <br>
•	Для каждой пары (i, j) вершин источника и назначения соответственно есть два возможных случая. <br>
•	k не является промежуточной вершиной на кратчайшем пути от i до j . Мы сохраняем значение dist[i][j] как есть. <br>
•	k — промежуточная вершина на кратчайшем пути от i до j . Мы обновляем значение dist[i][j] как dist[i][k] + dist[k][j], если dist[i][j] > dist[i][k] + dist[k] [j]<br>

<h2>6.	Алгоритм Беллмана-Форда</h2>
Алгоритм Беллмана-Форда — алгоритм поиска кратчайшего пути во взвешенном графе. В отличие от алгоритма Дейкстры, алгоритм Беллмана-Форда допускает рёбра с отрицательным весом.<br>
Алгоритм работает следующим образом:<br>
Заведём массив расстояний d[0..n-1], который после отработки алгоритма будет содержать ответ на задачу. В начале работы мы заполняем его следующим образом: d[v]=0, а все остальные элементы d[] равны бесконечности.<br>
Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию (relax, ослабление) вдоль каждого ребра (a,b) стоимости c. Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a]+c. Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a.<br>
Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют). Для недостижимых вершин расстояние d[] останется равным бесконечности.<br>

</p>
</body>
</html>