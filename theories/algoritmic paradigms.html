<!DOCTYPE html>
<html>
<head>
    <title>Заголовки и абзацы</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>Алгоритмические методы</h1>
    <hr>
    <h2>1. Рекурсия</h2>
    <p> Рекурсия – функция, вызывающая саму себя.<br>
Чтобы рекурсия выполнялась, должны выполняться два условия:<br>
– должен существовать хотя бы один базовый случай (случай, когда вычисление происходит непосредственно, без рекурсии);<br>
– каждый рекурсивный вызов должен быть меньшим экземпляром той же задачи, так что в конечном итоге будет достигнут один из базовых случаев.<br>

<h2>2. Метод «грубой силы»</h2>
Полный перебор (или метод «грубой силы» от англ. brute force) — метод решения задачи путем перебора всех возможных вариантов. Сложность полного перебора зависит от количества всех возможных решений задачи. Хотя метод грубого поиска прост в реализации и всегда находит решение, если оно существует, затраты на реализацию пропорциональны количеству возможных решений, которое во многих практических задачах имеет тенденцию очень быстро расти по мере увеличения размера проблемы. Таким образом, поиск методом перебора обычно используется, когда размер проблемы ограничен. Метод также используется, когда простота реализации важнее скорости обработки. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий.<br>

<h2>3. Метод «Разделяй и Властвуй»</h2>
Решение задач с помощью метода "Разделяй и Властвуй" или по-английски "Divide and Conquer" является одним из базовых методов по ускорению алгоритмов.<br> 
Решение задачи с помощью данного подхода обладает следующими тремя свойствами:<br>
•	Разделить входные данные на меньшие подмножества.<br>
•	Решить подзадачи рекурсивно.<br>
•	Объединить решения подзадач в решение исходной задачи.<br>
Примером применения метода служит переход от квадратичной сложности пузырьковой сортировки или сортировки вставками к сложности O(n log(n)) при сортировке слиянием. Или переход от линейной сложности к логарифмической, при реализации поиска элемента в отсортированном массиве (выполнение бинарного поиска).<br>

<h2>4. Динамическое программирование</h2>
Динамическое программирование - это метод решения сложных задач путем их разбиения на более мелкие подзадачи и решения каждой подзадачи только один раз с сохранением решений подзадач, чтобы их можно было повторно использовать при необходимости. Идея заключается в том, что оптимальное решение зачастую можно найти, рассмотрев все возможные пути решения задачи, и выбрать среди них лучшее.<br>
Чтобы решить задачу динамически нужны 3 вещи:<br>
•	Таблица, в которую будут вноситься промежуточные результаты. Один из них будет выбран в конце работы алгоритма в качестве ответа<br>
•	Несколько правил по заполнению пустых ячеек таблицы, основанных на значениях в уже заполненных ячейках. <br>
•	Правило выбора финального решения после заполнения таблицы<br>
Примером задачи, которую можно решить с помощью динамического программирования, является вычисление чисел Фибоначчи.<br>

<h2>5. Жадные алгоритмы</h2>
Жадный алгоритм — алгоритм, заключающийся в принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. Общего критерия оценки применимости жадного алгоритма для решения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности: во-первых, к ним применим принцип жадного выбора, то есть последовательность локально оптимальных выборов даёт глобально оптимальное решение, а во-вторых, они обладают свойством оптимальности для подзадач, то есть оптимальное решение задачи содержит в себе оптимальные решения для всех её подзадач. <br>
Одной из задач, решение которой можно найти с помощью жадного алгоритма, является задача о размене монет.<br>

</body>
</html>