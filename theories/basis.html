<!DOCTYPE html>
<html>
<head>
    <title>Заголовки и абзацы</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>Основы</h1>
    <hr>
    <h2>1. Вычислительная сложность алгоритма</h2>
    <p> Вычислительная сложность алгоритма – оценка по времени выполнения и по объему используемой памяти алгоритма. Оцениваются ТОЛЬКО корректные алгоритмы – алгоритмы, завершающиеся получением правильного ответа.<br>
Как оценить эффективность алгоритма:<br>
– привязка оценки алгоритма к объему входных данных;<br>
– использование «элементарных» операций (арифметические операции, ввод-вывод, условный оператор, работа с переменными) для подсчета времени работы алгоритма.<br>
– при оценке скорости роста количества операций от размера входных данных можно пренебрегать менее значимыми компонентами и константами. Например, O(5n3+4n+3) ~ O(n3).<br>
<h2>2. Алгоритмы поиска</h2>
– линейный поиск – алгоритм поиска, при котором массив просматривается последовательно и проверяется каждый элемент. Сложность по времени: O(n).<br>
– бинарный поиск – алгоритм поиска, используемый в отсортированном массиве путем многократного деления интервала поиска пополам. Сложность по времени: O(logn).<br>
Идея поиска заключается в том, чтобы брать элемент посередине, между границами, и сравнивать его с искомым. Если искомое больше, чем элемент сравнения, то сужаем область поиска так, чтобы новая левая граница была равна индексу середины предыдущей области. В противном случае присваиваем это значение правой границе. Проделываем эту процедуру до тех пор, пока правая граница больше.<br>
– экспоненциальный поиск – алгоритм поиска, состоящий из двух этапов:<br>
– поиск диапазона, в котором присутствует элемент;<br>
– выполнение двоичного поиска в найденном диапазоне. <br>
Идея состоит в том, чтобы начать сравнение искомого значения с элементом массива под индексом 1, затем под индексом 2, затем 4 и так далее, пока последний элемент подмассива не станет больше. Как только мы находим индекс i, мы знаем, что элемент должен присутствовать между i/2 и i, и запускаем бинарный поиск.
Сложность по времени: O(logn).<br>
<h2>3. Алгоритм поиска подстроки в строке</h2>
	Наивный алгоритм<br>
Идея: идти по проверяемой строке T и искать в ней вхождение первого символа искомой строки P. Когда находим, делаем гипотезу, что это и есть то самое искомое вхождение. Затем остается проверять по очереди все последующие символы шаблона на совпадение с соответствующими символами строки T. Если они все совпали — значит мы нашли искомое вхождение. Но если какой-то из символов не совпал, то наша гипотеза не верна, что возвращает нас к символу, следующему за вхождением первого символа из P.<br>
Сложность по времени: O((n – m) * m), где n – длина строки T, m – длина подстроки P.<br>
	Алгоритм Рабина-Карпа<br>
Как и наивный алгоритм, алгоритм Рабина-Карпа также проверяет каждую подстроку. Но в отличие от наивного алгоритма, алгоритм Рабина Карпа сопоставляет хеш-значение шаблона с хеш-значением текущей подстроки текста, и если хеш-значения совпадают, то только он начинает сопоставлять отдельные символы. Таким образом, алгоритм Рабина Карпа должен вычислить хеш-значения для следующих строк.<br>
Хэш-значение используется для эффективной проверки потенциальных совпадений между шаблоном и подстроками более крупного текста. Хеш-значение вычисляется с помощью скользящей хеш-функции, которая позволяет обновить хэш-значение для новой подстроки, эффективно удаляя вклад старого символа и добавляя вклад нового символа. Это дает возможность провести паттерн по тексту и вычислить хеш-значение для каждой подстроки, не пересчитывая весь хеш с нуля.
Сложность по времени: O(n + m), где n – длина строки T, m – длина подстроки P.<br>
	Алгоритм Бойера-Мура<br>
Алгоритм сравнивает символы шаблона P справа налево, начиная с самого правого, один за другим с символами исходной строки T. Если символы совпадают, производится сравнение предпоследнего символа шаблона и так до конца. Если все символы шаблона совпали с наложенными символами строки, значит, подстрока найдена, и поиск окончен. В случае несовпадения какого-либо символа, то мы смещаем шаблон P так, что несовпадающий символ встал на место последнего элемента шаблона.<br>
Сложность по времени: O(n + m), где n – длина строки T, m – длина подстроки P.<br>
	Алгоритм Кнута-Морриса-Пратта<br>
Префикс-функция: <br>
Пусть дана строка S[0..n], необходимо вычислить для нее префикс-функцию, то есть получить массив p[0..n-1], где p[i] определяется следующим образом: p[i] – наибольшая длина наибольшего собственного суффикса подстроки s[0..i], то есть p[i] = max(k: s[0..k-1] = s[i-k+1..i]). Например, для строки “abcabcd” префикс функция [0, 0, 0, 1, 2, 3, 0].<br>
 
a – 0<br>
ab – 0 <br>
abc – 0 <br>
abca – 1<br>
abcab – 2 <br>
abcabc – 3 <br>
abcabcd – 0 <br>
 
Алгоритм Кнута-Морриса-Пратта:<br>
Для нахождения образца “aabaa” в строке “aabaaaabaaaaabbaba” склеим образец со строкой, используя разделитель (символ, которого нет ни в строке, ни в образце): 
“aabaa@aabaaaabaaaaabbaba”, и вызовем для получившейся строки префикс-функцию. Ищем в получившемся массиве элементы, равные длине образца, и выводим индексы, под которыми они находятся. Значений, больших длине образца, не будет из-за символа разделителя, а значения, равные длине образца, могут появиться только в позициях, соответствующих образцу.<br>
<h2>4. Алгоритм Евклида</h2>
Алгоритм Евклида — эффективный алгоритм для нахождения наибольшего общего делителя двух целых чисел.<br>
Утверждение<br>
Для любых двух натуральных чисел a>b верно следующее равенство: НОД(a,b) = НОД(a-b;b)<br>
На этом утверждении основан простой способ отыскания наибольшего общего делителя двух чисел. Он называется алгоритм Евклида и заключается в следующем: для нахождения наибольшего общего делителя двух чисел нужно заменить большее из чисел на остаток от деления его на меньшее и для полученной пары повторять эту процедуру, пока одно из чисел не станет равно нулю. Тогда второе число будет равно наибольшему общему делителю исходных чисел. <br>

Например, НОД(175; 90) = НОД(85; 90) = НОД(85; 5) = НОД(0; 5) = 5.<br>

<h2>5. Решето Эратосфена</h2>
Решето Эратосфена — алгоритм нахождения всех простых чисел до некоторого целого числа n. Название алгоритма говорит о принципе его работы: алгоритм осуществляет фильтрацию списка чисел от 2 до n. По мере прохождения списка составные числа исключаются, а простые остаются.<br>
Для нахождения всех простых чисел не больше заданного числа n, следуя методу Эратосфена, нужно выполнить следующие шаги:<br>

1.Выписать подряд все целые числа от двух до n (2, 3, 4, …, n).<br>
2.Пусть переменная p изначально равна двум — первому простому числу.<br>
3.Зачеркнуть в списке числа от 2p до n, считая шагами по p (это будут числа, кратные p: 2p, 3p, 4p, …).<br>
4.Найти первое незачёркнутое число в списке, большее чем p, и присвоить значению переменной p это число.<br>
5.Повторять шаги 3 и 4, пока возможно.<br>
Теперь все незачёркнутые числа в списке — это все простые числа от 2 до n.<br>
</p>
</body>
</html>