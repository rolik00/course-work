1. Массив
Массив – структура данных, для которой характерно:
•	Хранение элементов одного типа
•	Размещение элементов последовательно в памяти
•	Единое имя для всех элементов

Тип операции 		       Начало	Середина	Конец
Вставка элемента 		O(n)	O(n)		O(1)
Удаление элемента 		O(n)	O(n)		O(1)
Произвольный доступ к элементу	O(1)	O(1)		O(1)

Имя массива указывает на адрес в памяти его самого первого элемента. Доступ ко всем остальным элементам осуществляется при помощи индексов или смещений. Первый элемент имеет индекс 0 (нулевое смещение).

Динамический массив – массив, размер которого может изменяться во время исполнения программы. Возможность изменения размера отличает динамический массив от статического, размер которого задаётся на момент компиляции программы.

2. Связный список
Список (связный список) — это структура данных, состоящая из объектов специального вида, которые называются узлами. Узлы хранят само значение и указатель на следующий узел. 
Плюсом связного списка является невозможность переполнения. К минусам можно отнести использование дополнительной памяти для указателей и отсутствие произвольного доступа к элементам. 
Тип операции 	             Сложность
Взять первый			O(1) 
Взять последний			O(n) 
Вставка в начало		O(1) 
Вставка в конец 		O(n) 
Вставка по заданному значению	O(n) 
Удаление первого		O(1) 
Удаление последнего		O(n) 
Удаление по значению		O(n) 
Поиск элемента			O(n) 

3. Стек
Стек — это структура данных, работающая по принципу “последним добавлен – первым возвращен” – Last In First Out (LIFO). Возможна реализация через список или через массив.
Основные операции: 
•	Доступ (посмотреть на вершину) = top 	- O(1)
•	Вставка в конец = push 			– O(1)
•	Удаление последнего элемента = pop 	– O(1)
•	Проверка на пустоту = is_empty 		– O(1)
•	Проверка на полноту = is_full 		– O(1)
Задачи на использование стека: определение правильной скобочной последовательности, калькулятор через обратную польскую запись.

4. Очередь
Очередь — это структура данных, работающая по принципу “первым добавлен – первым возвращен” – First In First Out (FIFO). Возможна реализация на массиве, куче или на 2 стеках.
 Основные операции:
•	Доступ (получение первого и последнего элемента) = front & rear 	– O(1) 
•	Вставка (в конец очереди) = enqueue 					– O(1)
•	Удаление первого элемента = dequeue 					– O(n)
•	Проверка на пустоту = is_empty 						– O(1)
Задачи на использование очереди: поиск в ширину в графе (BFS).

5. Дерево
Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы.
Каждый элемент — это вершина или узел дерева. Узлы, соединенные направленными дугами, называются ветвями. Начальный узел — это корень дерева (корневой узел). Листья — это узлы, в которые входит 1 ветвь, причем не выходит ни одной. Также у дерева есть высота (глубина). Она определяется числом уровней, на которых располагаются узлы дерева. Степень вершины в дереве — это число ветвей, выходящих из этой вершины. Степень равняется максимальной степени вершины, которая входит в дерево.
Существует много древовидных структур данных: двоичные (бинарные), красно-черные, В-деревья, матричные, смешанные и пр.
Бинарные деревья имеют степень не более двух. То есть двоичным древом можно назвать динамическую структуру данных, где каждый узел имеет не большое 2-х потомков. В результате двоичное дерево состоит из элементов, где каждый из элементов содержит информационное поле, а также не больше 2-х ссылок на различные поддеревья. На каждый элемент древа есть только одна ссылка.
У бинарного дерева каждый текущий узел — это структура, которая состоит из 4-х видов полей. Какие это поля:
— информационное (ключ вершины);
— служебное (включена вспомогательная информация, однако таких полей может быть несколько, а может и не быть вовсе);
— указатель на правое поддерево;
— указатель на левое поддерево.

6. Куча
Куча - двоичное дерево, для которого выполнены три условия:
•	Значение в любой вершине не меньше, чем значения ее потомков.
•	Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
•	Последний слой заполняется слева направо.
Элементы хранятся в массиве. Чтобы найти предка: (i -1) / 2 или / d , где d – индекс кучи. Чтобы найти потомка: 2*i+1, 2*i+2 или d*i+1 и т. д.
Вставка: вставка в конец массива и sift-up – O(log n)
Получить min/max – первый элемент кучи – O(1)
Удалить min/max – поменять местами первый и последний элемент, уменьшаем размер кучи на 1 и делаем sift-down – O(logn)

7. Хэш-таблица 
Хэш-таблица представляет собой структуру данных, реализующую ассоциативный массив, также называемый словарем, который представляет собой абстрактный тип данных, сопоставляющий ключи со значениями. Хэш-таблица использует хэш-функцию для вычисления индекса, также называемого хэш-кодом, в массиве, из которого можно найти желаемое значение. Во время поиска ключ хэшируется, и полученный хэш указывает, где хранится соответствующее значение. Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, все три операции (добавление, удаление, поиск элемента) в среднем выполняются за время O(1).
В идеале хеш-функция присваивает каждому ключу уникальный сегмент, но в большинстве проектов хеш-таблиц используется несовершенная хеш-функция, которая может вызвать хеш- коллизии, когда хеш-функция генерирует один и тот же индекс для более чем одного ключа. Такие коллизии обычно каким-то образом учитываются.
Во многих ситуациях хеш-таблицы оказываются в среднем более эффективными, чем деревья поиска или любая другая структура поиска в таблицах. По этой причине они широко используются во многих видах компьютерного программного обеспечения.
