1. Поиск в глубину
“Поиск в глубину” или “обход в глубину” — это алгоритм по поиску всех вершин графа или дерева. Обход подразумевает под собой посещение всех вершин графа. 
Стандартная реализация поиска в глубину помещает каждую вершину графа в одну из двух категорий: пройденные или не пройденные. Цель алгоритма состоит в том, чтобы пометить каждую вершину как “Пройденная”, избегая при этом циклов.
Алгоритм поиска в глубину работает следующим образом:
1.	Начните с того, что поместите любую вершину графа на вершину стека.
2.	Возьмите верхний элемент стека и добавьте его в список “Пройденных”.
3.	Создайте список смежных вершин для этой вершины. Добавьте те вершины, которых нет в списке “Пройденных”, в верх стека.
4.	Необходимо повторять шаги 2 и 3, пока стек не станет пустым.
Применения алгоритма:
•	Для поиска пути.
•	Для проверки двудольности графа.
•	Для поиска сильно связанных компонентов графа.
•	Для обнаружения циклов в графе.
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.

2. Поиск в ширину
Поиск в ширину — один из методов обхода графа. 
Шаги работы алгоритма:
•	Поместить узел, с которого начинается поиск, в изначально пустую очередь.
•	Извлечь из начала очереди узел u и пометить его как развёрнутый.
•	Если узел u является целевым узлом, то завершить поиск с результатом «успех».
•	В противном случае, в конец очереди добавляются все преемники узла u, которые ещё не развёрнуты и не находятся в очереди.
•	Если очередь пуста, то все узлы связного графа были просмотрены, следовательно, целевой узел недостижим из начального; завершить поиск с результатом «неудача».
•	Вернуться к п. 2.
Сложность алгоритма составляет O(|V|+|E|), где V и E - число вершин и рёбер в графе соответственно.
Поиск в ширину может применяться для решения задач, связанных с теорией графов:
•	Волновой алгоритм поиска пути в лабиринте
•	Поиск компонент связности в графе
•	Поиск кратчайшего пути между двумя узлами невзвешенного графа
•	Нахождение кратчайшего цикла в ориентированном невзвешенном графе

3. Волновой алгоритм (алгоритм Ли)
Волновой алгоритм или алгоритм Ли — это алгоритм поиска пути, который использует волновое распространение для определения кратчайшего пути от начальной вершины до целевой вершины. Первоначально использовался для поиска пути в лабиринте или в игровых задачах. В настоящее время алгоритм является основным в микроэлектронике для трассировки (соединения) элементов интегральных схем.
Работа алгоритма включает в себя три этапа: инициализацию, распространение волны и восстановление пути.
1. Во время инициализации строится образ множества ячеек обрабатываемого поля, каждой ячейке приписываются атрибуты проходимости/непроходимости, запоминаются стартовая и финишная ячейки.
2. От стартовой ячейки порождается шаг в соседнюю ячейку, при этом проверяется, проходима ли она, и не принадлежит ли ранее меченной в пути ячейке.
При выполнении условий проходимости и непринадлежности её к ранее помеченным в пути ячейкам, в атрибут ячейки записывается число, равное количеству шагов от стартовой ячейки, от стартовой ячейки на первом шаге это будет 1. Каждая ячейка, меченая числом шагов от стартовой ячейки становится стартовой и из неё порождаются очередные шаги в соседние ячейки. Очевидно, что при таком переборе будет найден путь от начальной ячейки к конечной, либо очередной шаг из любой порождённой в пути ячейки будет невозможен.
3. Восстановление кратчайшего пути происходит в обратном направлении: при выборе ячейки от финишной ячейки к стартовой на каждом шаге выбирается ячейка, имеющая атрибут расстояния от стартовой на единицу меньше текущей ячейки. Очевидно, что таким образом находится кратчайший путь между парой заданных ячеек.

4. Алгоритм Дейкстры
Алгоритм Дейкстры — алгоритм на графах, применяющийся для нахождения кратчайших путей от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.
Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.
Инициализация.
Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.
Шаг алгоритма.
•	Если все вершины посещены, алгоритм завершается.
•	В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.
•	Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.
•	Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

5. Алгоритм Флойда-Уоршелла
Алгоритм Флойда Уоршелла представляет собой алгоритм поиска кратчайшего пути для всех пар, в отличие от Дейкстры и Беллмана-Форда, которые представляют собой алгоритмы поиска кратчайшего пути для одной вершины. Этот алгоритм работает как для ориентированных, так и для неориентированных взвешенных графов, а также для графов как с положительными, так и с отрицательными весами ребер, но не работает для графов с отрицательными циклами (где сумма ребер в цикле отрицательна). Он следует подходу динамического программирования, который проверяет каждый возможный путь, проходящий через каждый возможный узел, чтобы вычислить кратчайшее расстояние между каждой парой узлов.
•	В качестве первого шага инициализируйте матрицу решения так же, как матрицу входного графа. 
•	Затем обновите матрицу решения, рассматривая все вершины как промежуточные. 
•	Идея состоит в том, чтобы выбрать все вершины одну за другой и обновить все кратчайшие пути, которые включают выбранную вершину в качестве промежуточной вершины в кратчайшем пути. 
•	Когда мы выбираем вершину номер k в качестве промежуточной вершины, мы уже рассматриваем вершины {0, 1, 2, .. k-1} как промежуточные вершины. 
•	Для каждой пары (i, j) вершин источника и назначения соответственно есть два возможных случая. 
•	k не является промежуточной вершиной на кратчайшем пути от i до j . Мы сохраняем значение dist[i][j] как есть. 
•	k — промежуточная вершина на кратчайшем пути от i до j . Мы обновляем значение dist[i][j] как dist[i][k] + dist[k][j], если dist[i][j] > dist[i][k] + dist[k] [j]

6.	Алгоритм Беллмана-Форда 
Алгоритм Беллмана-Форда — алгоритм поиска кратчайшего пути во взвешенном графе. В отличие от алгоритма Дейкстры, алгоритм Беллмана-Форда допускает рёбра с отрицательным весом.
Алгоритм работает следующим образом:
Заведём массив расстояний d[0..n-1], который после отработки алгоритма будет содержать ответ на задачу. В начале работы мы заполняем его следующим образом: d[v]=0, а все остальные элементы d[] равны бесконечности.
Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию (relax, ослабление) вдоль каждого ребра (a,b) стоимости c. Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a]+c. Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a.
Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют). Для недостижимых вершин расстояние d[] останется равным бесконечности.
